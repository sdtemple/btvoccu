View(posterior_effects(ab))
occueffs <- c("intercept",
"sqrt.perc.agri",
"sqrt.perc.urban",
"lag6meantemp.wk",
"lag2gini.bird.simpson")
deteffs <- c("intercept",
"sqrt.X.surveys",
"sqrt.Cx.prop",
"cbrt.catch.rate")
ae <- btvoccu(niter,
x, y,
sites,
seasons,
periods,
occueffs,
deteffs,
logit = logit,
nchains = nchains,
print.interval = print.interval)
View(posterior_effects(ae))
waic_score(ae, x, z)
waic_score(ad, x, z)
waic_score(ae, x, y)
# spatial effects
arealeffs <- c('sqrt.perc.agri', 'sqrt.perc.urban')
x <- append_spatial_effects(x, arealeffs, A)
speffs <- paste('sp', 1:3, sep = '')
?btvoccu
ad <- btvoccu(niter,
x, y,
sites,
seasons,
periods,
occueffs,
deteffs,
speffs,
A,
logit = logit,
nchains = nchains,
print.interval = print.interval)
af <- btvoccu(niter,
x, y,
sites,
seasons,
periods,
occueffs,
deteffs,
speffs,
A,
logit = logit,
nchains = nchains,
print.interval = print.interval)
View(posterior_effects(af))
waic_score(ag, x, z)
waic_score(af, x, z)
waic_score(af, x, y)
occueffs <- c("intercept",
"sqrt.perc.agri",
"sqrt.perc.urban",
"sqrt.wks.meantemp.below.freezing",
"lag6meantemp.wk",
"lag2gini.bird.simpson")
deteffs <- c("intercept",
"sqrt.X.surveys",
"sqrt.Cx.prop",
"cbrt.catch.rate")
# spatial effects
arealeffs <- c('sqrt.perc.agri', 'sqrt.perc.urban')
x <- append_spatial_effects(x, arealeffs, A)
speffs <- paste('sp', 1:3, sep = '')
af <- btvoccu(niter,
x, y,
sites,
seasons,
periods,
occueffs,
deteffs,
speffs,
A,
logit = logit,
nchains = nchains,
print.interval = print.interval)
occueffs <- c("intercept",
"sqrt.perc.agri",
"sqrt.perc.urban",
"sqrt.wks.meantemp.below.freezing",
"lag6meantemp.wk",
"lag2gini.bird.simpson")
deteffs <- c("intercept",
"sqrt.X.surveys",
"sqrt.Cx.prop",
"cbrt.catch.rate")
# spatial effects
arealeffs <- c('sqrt.perc.agri', 'sqrt.perc.urban')
x <- append_spatial_effects(x, arealeffs, A)
speffs <- paste('sp', 1:3, sep = '')
af <- btvoccu(niter,
x, y,
sites,
seasons,
periods,
occueffs,
deteffs,
speffs,
A,
logit = logit,
nchains = nchains,
print.interval = print.interval)
occueffs <- c("intercept",
"sqrt.perc.agri",
"sqrt.perc.urban",
"lag6meantemp.wk",
"lag2gini.bird.simpson")
deteffs <- c("intercept",
"sqrt.X.surveys",
"sqrt.Cx.prop",
"cbrt.catch.rate")
# spatial effects
arealeffs <- c('sqrt.perc.agri', 'sqrt.perc.urban')
x <- append_spatial_effects(x, arealeffs, A)
speffs <- paste('sp', 1:3, sep = '')
af <- btvoccu(niter,
x, y,
sites,
seasons,
periods,
occueffs,
deteffs,
speffs,
A,
logit = logit,
nchains = nchains,
print.interval = print.interval)
# spatial effects
arealeffs <- c('sqrt.perc.agri', 'sqrt.perc.urban')
x <- append_spatial_effects(x, arealeffs, A)
speffs <- paste('sp', 1:2, sep = '')
af <- btvoccu(niter,
x, y,
sites,
seasons,
periods,
occueffs,
deteffs,
speffs,
A,
logit = logit,
nchains = nchains,
print.interval = print.interval)
View(A)
occueffs <- c("intercept",
"sqrt.perc.agri",
"sqrt.perc.urban",
"lag6meantemp.wk",
"lag2gini.bird.simpson")
deteffs <- c("intercept",
"sqrt.X.surveys",
"sqrt.Cx.prop",
"cbrt.catch.rate")
# spatial effects
arealeffs <- c('sqrt.perc.agri', 'sqrt.perc.urban')
dimnames(x)[[4]]
x <- readRDS("data/fewer-covariates.rds")
x <- apply(x, 1:4, as.numeric)
occueffs <- c("intercept",
"sqrt.perc.agri",
"sqrt.perc.urban",
"sqrt.wks.meantemp.below.freezing",
"lag6meantemp.wk",
"lag2gini.bird.simpson")
deteffs <- c("intercept",
"sqrt.X.surveys",
"sqrt.Cx.prop",
"cbrt.catch.rate")
# spatial effects
arealeffs <- c('sqrt.perc.agri', 'sqrt.perc.urban')
x <- append_spatial_effects(x, arealeffs, A)
speffs <- paste('sp', 1:2, sep = '')
af <- btvoccu(niter,
x, y,
sites,
seasons,
periods,
occueffs,
deteffs,
speffs,
A,
logit = logit,
nchains = nchains,
print.interval = print.interval)
View(posterior_effects(af))
waic_score(af, x, z)
y <- readRDS("data/response.rds")
x <- readRDS("data/covariates.rds")
y <- apply(y, 1:4, as.numeric)
x <- apply(x, 1:4, as.numeric)
x <- append_transformed_term(x, "trees", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "veg", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "agri", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "urban", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "water", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "perc.trees", sqrt, "sqrt.")
x <- append_transformed_term(x, "perc.veg", sqrt, "sqrt.")
x <- append_transformed_term(x, "perc.agri", sqrt, "sqrt.")
x <- append_transformed_term(x, "perc.urban", sqrt, "sqrt.")
x <- append_transformed_term(x, "perc.water", sqrt, "sqrt.")
x <- append_transformed_term(x, "popdensity", log10, "log10.")
x <- append_transformed_term(x, "popdensity", sqrt, "sqrt.")
x <- append_transformed_term(x, "X.surveys", log, "log.")
x <- append_transformed_term(x, "X.surveys", sqrt,  "sqrt.")
x <- append_transformed_term(x, "catch.rate", sqrt, "sqrt.")
x <- append_transformed_term(x, "catch.rate", function(x){return(x**(1/3))}, "cbrt.")
x <- append_transformed_term(x, "Cx.prop", sqrt, "sqrt.")
x <- append_transformed_term(x, "Cx.prop", function(x){return(x**(1/3))}, "cbrt.")
x <- append_transformed_term(x, "wks.meantemp.below.freezing", sqrt, "sqrt.")
x <- append_principal_components(x, dimnames(x)[[4]][5:16], 2, "climate")
x <- append_transformed_term(x, "bird.richness", function(x){log(x)}, "log.")
x <- append_transformed_term(x, "bird.abundance", function(x){log10(x)}, "log10.")
x <- append_transformed_term(x, "bird.simpson", function(x){1/x}, "inv.")
x <- append_transformed_term(x, "bird.simpson", function(x){1-x}, "gini.")
# lags
x <- append_lagged_terms(x, "meantemp.wk", c(2,4,6,8))
x <- append_lagged_terms(x, "precip.wk", c(2,4,6,8))
x <- append_lagged_terms(x, "sqrt.level.avg.avg", c(2,4,6,8))
y <- readRDS("data/response.rds")
x <- readRDS("data/covariates.rds")
y <- apply(y, 1:4, as.numeric)
x <- apply(x, 1:4, as.numeric)
# Transform ---------------------------------------------------------------
# land cover
x <- append_transformed_term(x, "trees", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "veg", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "agri", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "urban", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "water", function(x){x / 100}, "perc.")
x <- append_transformed_term(x, "perc.trees", sqrt, "sqrt.")
x <- append_transformed_term(x, "perc.veg", sqrt, "sqrt.")
x <- append_transformed_term(x, "perc.agri", sqrt, "sqrt.")
x <- append_transformed_term(x, "perc.urban", sqrt, "sqrt.")
x <- append_transformed_term(x, "perc.water", sqrt, "sqrt.")
# population density
x <- append_transformed_term(x, "popdensity", log10, "log10.")
x <- append_transformed_term(x, "popdensity", sqrt, "sqrt.")
# traps
x <- append_transformed_term(x, "X.surveys", log, "log.")
x <- append_transformed_term(x, "X.surveys", sqrt,  "sqrt.")
x <- append_transformed_term(x, "catch.rate", sqrt, "sqrt.")
x <- append_transformed_term(x, "catch.rate", function(x){return(x**(1/3))}, "cbrt.")
x <- append_transformed_term(x, "Cx.prop", sqrt, "sqrt.")
x <- append_transformed_term(x, "Cx.prop", function(x){return(x**(1/3))}, "cbrt.")
x <- append_transformed_term(x, "wks.meantemp.below.freezing", sqrt, "sqrt.")
x <- append_principal_components(x, dimnames(x)[[4]][5:16], 2, "climate")
# hydrology
x <- append_transformed_term(x, "level.avg.avg", sqrt, "sqrt.")
x <- append_transformed_term(x, "level.avg.max", sqrt, "sqrt.")
x <- append_transformed_term(x, "bird.richness", function(x){log(x)}, "log.")
x <- append_transformed_term(x, "bird.abundance", function(x){log10(x)}, "log10.")
x <- append_transformed_term(x, "bird.simpson", function(x){1/x}, "inv.")
x <- append_transformed_term(x, "bird.simpson", function(x){1-x}, "gini.")
x <- append_lagged_terms(x, "meantemp.wk", c(2,4,6,8))
x <- append_lagged_terms(x, "precip.wk", c(2,4,6,8))
x <- append_lagged_terms(x, "sqrt.level.avg.avg", c(2,4,6,8))
x <- append_lagged_terms(x, "gini.bird.simpson", c(2,4,6,8))
# many covariates
saveRDS(x, "data/many-covariates.rds")
# prune covariates
w <- subset_4darray(x, 4, c("intercept",
"popdensity",
"log10.popdensity",
"meantemp.wk",
"lag2meantemp.wk",
"lag4meantemp.wk",
"lag6meantemp.wk",
"lag8meantemp.wk",
"precip.wk",
"lag2precip.wk",
"lag4precip.wk",
"lag6precip.wk",
"lag8precip.wk",
"sqrt.level.avg.avg",
"lag2sqrt.level.avg.avg",
"lag4sqrt.level.avg.avg",
"lag6sqrt.level.avg.avg",
"lag8sqrt.level.avg.avg",
"wks.meantemp.below.freezing",
"sqrt.wks.meantemp.below.freezing",
"climate.pc1",
"climate.pc2",
"daylight",
"X.surveys",
"sqrt.X.surveys",
"log.X.surveys",
"Cx.prop",
"sqrt.Cx.prop",
"cbrt.Cx.prop",
"catch.rate",
"sqrt.catch.rate",
"cbrt.catch.rate",
"perc.trees",
"perc.agri",
"perc.urban",
"perc.water",
"sqrt.perc.trees",
"sqrt.perc.agri",
"sqrt.perc.urban",
"sqrt.perc.water",
"gini.bird.simpson",
"lag2gini.bird.simpson",
"lag4gini.bird.simpson",
"lag6gini.bird.simpson",
"lag8gini.bird.simpson",
"log.bird.richness"))
saveRDS(w, "data/fewer-covariates.rds")
?btvoccu
?btvoccu
posterior_correlations(a, "Sigmabetas")
posterior_variances(a, "sigmathetas")
posterior_variances(ag, "sigmathetas")
posterior_variances(af, "sigmathetas")
posterior_variances(af, "Sigmabetas")
posterior_effects(af)
#'
#' @param model \code{btvoccu} model object
#' @param Sigmas "Sigmabetas", "Sigmaalphas", or "sigmathetas"
#' @param burnin percent of posterior samples to burn
#' @param thin keep every nth posterior draw
#' @param credible quantiles
#'
#' @return matrix
#'
#' @export
posterior_variances <- function(model, Sigmas, burnin = .5, thin = 1, credible = c(.025,.5,.975)){
mjridx <- which(names(model) == Sigmas, arr.ind = T)
out <- model[[mjridx]]
keep <- seq(ceiling(burnin * model$niter), model$niter, by = thin)
nchains <- model$nchains
if(Sigmas == "sigmathetas"){
if(is.null(model$sigmathetas)){
stop("This model is not a spatial model.")
}
# format as coda mcmc object
mcmc <- coda::mcmc.list()
for(k in 1:nchains){
mcmc[[k]] <- out[k, keep, 1]
}
# check chain convergence
rhat <- coda::gelman.diag(mcmc, autoburnin = F)[[1]][1]
# combine chains
vec <- as.vector(out[1, keep, 1])
for(k in 2:nchains){vec <- c(vec, as.vector(out[k, keep, 1]))}
# store in table
table <- matrix(nrow = 0, ncol = (length(credible) + 2))
table <- rbind(table, c(quantile(vec, credible), mean(vec), rhat))
rownames(table)[1] <- "sigmathetasq"
colnames(table) <- c(credible, "mean", "rhat")
return(table)
}
n <- 0
table <- matrix(nrow = 0, ncol = (length(credible) + 3))
for(i in 1:(dim(out)[3])){
name <- names(model)[mjridx+3][i]
# format as coda mcmc object
mcmc <- coda::mcmc.list()
chains <- apply(out[,keep,i,i], 1, as.numeric)
for(k in 1:nchains){mcmc[[k]] <- coda::as.mcmc(chains[,k])}
# check chain convergence
rhat <- coda::gelman.diag(mcmc, autoburnin = F)[[1]][1]
# combine chains
vec <- as.vector(mcmc[[1]])
for(k in 2:nchains){vec <- c(vec, as.vector(mcmc[[k]]))}
# store in table
n <- n + 1
table <- rbind(table, c(name, quantile(vec, credible), mean(vec), rhat))
rownames(table)[n] <- paste(substr(names(model)[mjridx],
1, (nchar(names(model)[mjridx])-1)),
i, i, sep = "")
}
colnames(table) <- c("covariate", credible, "mean", "rhat")
return(table)
}
posterior_variances(a, "Sigmabetas")
names(a)
#'
#' @param model \code{btvoccu} model object
#' @param Sigmas "Sigmabetas", "Sigmaalphas", or "sigmathetas"
#' @param burnin percent of posterior samples to burn
#' @param thin keep every nth posterior draw
#' @param credible quantiles
#'
#' @return matrix
#'
#' @export
posterior_variances <- function(model, Sigmas, burnin = .5, thin = 1, credible = c(.025,.5,.975)){
mjridx <- which(names(model) == Sigmas, arr.ind = T)
out <- model[[mjridx]]
keep <- seq(ceiling(burnin * model$niter), model$niter, by = thin)
nchains <- model$nchains
if(Sigmas == "sigmathetas"){
if(is.null(model$sigmathetas)){
stop("This model is not a spatial model.")
}
# format as coda mcmc object
mcmc <- coda::mcmc.list()
for(k in 1:nchains){
mcmc[[k]] <- out[k, keep, 1]
}
# check chain convergence
rhat <- coda::gelman.diag(mcmc, autoburnin = F)[[1]][1]
# combine chains
vec <- as.vector(out[1, keep, 1])
for(k in 2:nchains){vec <- c(vec, as.vector(out[k, keep, 1]))}
# store in table
table <- matrix(nrow = 0, ncol = (length(credible) + 2))
table <- rbind(table, c(quantile(vec, credible), mean(vec), rhat))
rownames(table)[1] <- "sigmathetasq"
colnames(table) <- c(credible, "mean", "rhat")
return(table)
}
n <- 0
table <- matrix(nrow = 0, ncol = (length(credible) + 3))
for(i in 1:(dim(out)[3])){
nameidx <- names(model)[mjridx+3]
name <- getElement(model, nameidx)[i]
# format as coda mcmc object
mcmc <- coda::mcmc.list()
chains <- apply(out[,keep,i,i], 1, as.numeric)
for(k in 1:nchains){mcmc[[k]] <- coda::as.mcmc(chains[,k])}
# check chain convergence
rhat <- coda::gelman.diag(mcmc, autoburnin = F)[[1]][1]
# combine chains
vec <- as.vector(mcmc[[1]])
for(k in 2:nchains){vec <- c(vec, as.vector(mcmc[[k]]))}
# store in table
n <- n + 1
table <- rbind(table, c(name, quantile(vec, credible), mean(vec), rhat))
rownames(table)[n] <- paste(substr(names(model)[mjridx],
1, (nchar(names(model)[mjridx])-1)),
i, i, sep = "")
}
colnames(table) <- c("covariate", credible, "mean", "rhat")
return(table)
}
posterior_variances(a, "Sigmabetas")
View(posterior_variances(a, "Sigmabetas"))
View(posterior_variances(af, "Sigmabetas"))
#'
#' @param model \code{btvoccu} model object
#' @param Sigmas "Sigmabetas" or "Sigmaalphas"
#' @param burnin percent of posterior samples to burn
#' @param thin keep every nth posterior draw
#' @param credible quantiles
#'
#' @return matrix
#'
#' @export
posterior_correlations <- function(model, Sigmas, burnin = .5, thin = 1, credible = c(.025,.5,.975)){
mjridx <- which(names(model) == Sigmas, arr.ind = T)
nameidx <- names(model)[mjridx+3]
out <- model[[mjridx]]
keep <- seq(ceiling(burnin * model$niter), model$niter, by = thin)
n <- 0
table <- matrix(nrow = 0, ncol = (length(credible) + 4))
for(i in 1:(dim(out)[3] - 1)){
namei <- getElement(model, nameidx)[i]
for(j in (i+1):dim(out)[3]){
namej <- getElement(model, nameidx)[j]
# format as coda mcmc object
mcmc <- coda::mcmc.list()
chains <- apply(out[,keep,i,j] / sqrt(out[,keep,i,i] * out[,keep,j,j]),
1, as.numeric)
for(k in 1:dim(chains)[2]){mcmc[[k]] <- coda::as.mcmc(chains[,k])}
# check chain convergence
rhat <- coda::gelman.diag(mcmc, autoburnin = F)[[1]][1]
# combine chains
vec <- as.vector(mcmc[[1]])
for(k in 2:dim(chains)[2]){vec <- c(vec,as.vector(mcmc[[k]]))}
# store in table
n <- n + 1
table <- rbind(table, c(namei, namej, quantile(vec, credible), mean(vec), rhat))
rownames(table)[n] <- paste(substr(names(model)[mjridx],
1, (nchar(names(model)[mjridx])-1)),
i, j, sep = "")
}
}
colnames(table) <- c("covariate1", "covariate2", credible, "mean", "rhat")
return(table)
}
posterior_correlations(d, "Sigmabetas")
posterior_correlations(af, "Sigmabetas")
View(posterior_correlations(af, "Sigmabetas"))
xtable(posterior_correlations(af, "Sigmabetas"))
getwd()
setwd("C:/Users/Owner/Dropbox/GitHub/btvoccu/R")
library(devtools)
devtools::document()
devtools::install()
library(devtools)
devtools::document()
devtools::install()
devtools::document()
devtools::install()
library(devtools)
?btvoccu
library(btvoccu)
?btvoccu
getwd()
devtools::document()
devtools::install()
library(devtools)
devtools::document()
devtools::install()
